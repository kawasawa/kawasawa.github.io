# Generated by GitHub Copilot

import asyncio
import json
import os
import sys
from enum import IntEnum
from typing import Any, Dict, Optional

from comment_searcher import CommentSearcher
from config import MCPServerConfig, VectorSearchConfig
from logger import mcp_logger


class MCPServer:
    """
    ワークスペース内のコメントを検索・提供するMCPサーバ
    Model Context Protocol (MCP) を使用して、生成AIが指定のアノテーションコメントタグが付与されたコメントを情報源として活用できるようにする
    """

    def __init__(self, workspace_root: str, annotation_tag: str):
        """
        MCPサーバの初期化
        Args:
            workspace_root (str): ワークスペースのルートディレクトリ
            annotation_tag (str): 抽出対象のアノテーションコメントタグ
        """
        self.workspace_root = workspace_root
        self.server_name = os.path.basename(os.path.dirname(os.path.abspath(__file__)))
        self.comment_searcher = CommentSearcher(workspace_root, annotation_tag)

    async def run(self):
        """
        MCPサーバを実行
        標準入力からJSONリクエストを読み取り、標準出力にレスポンスを出力
        """

        while True:
            try:
                # NOTE: MCP クライアントと MCP サーバは標準入出力で JSON-RPC のやり取りを行う
                #   標準入出力により処理を行うため、そもそもネットワーク通信が発生しておらず、認証やポート指定等も不要である
                #   HTTP サーバとは異なり、MCP サーバは JSON-RPC を標準入力で受け取り処理する単純なコンソールアプリである
                #   また、ここでの MCP クライアントとは、正確には VSCode ではなくその拡張機能である GitHub Copilot に内包された機能である

                # 標準入力から1行読み取り
                # C# の Console.ReadLine() に相当
                line = await asyncio.get_event_loop().run_in_executor(
                    None, sys.stdin.readline
                )
                if not line:
                    break

                # 先頭と末尾の空白を除去
                line = line.strip()
                if not line:
                    continue

                # JSONリクエストをパース
                try:
                    request = json.loads(line)
                except json.JSONDecodeError:
                    error_response = self._create_error_response(
                        MCPErrorCode.PARSE_ERROR, "無効なJSON"
                    )
                    print(json.dumps(error_response))
                    continue

                # リクエストを処理
                response = await self.handle_request(request)

                # レスポンスを返却（標準出力）
                print(json.dumps(response, ensure_ascii=False))
                sys.stdout.flush()

            except KeyboardInterrupt:
                break

            except Exception as e:
                error_response = self._create_error_response(
                    MCPErrorCode.INTERNAL_ERROR, f"内部エラー: {str(e)}"
                )
                print(json.dumps(error_response))

    async def handle_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        MCPリクエストを処理
        Args:
            request (Dict[str, Any]): MCPリクエスト
        Returns:
            Dict[str, Any]: MCPレスポンス
        """

        # NOTE: MCP プロトコルでは通信に JSON-RPC を用い、その際の method の名称に決まりがある
        #   必須
        #     initialize:     サーバ初期化
        #   任意
        #     tools/list:     ツール一覧取得
        #     tools/call:     ツール実行
        #     resources/list: リソース一覧取得
        #     resources/read: リソース読み取り
        #     prompts/list:   プロンプト一覧取得
        #     prompts/get:    プロンプト取得

        method = request.get("method")
        params = request.get("params", {})
        request_id = request.get("id")

        mcp_logger.info(f"メソッド {method} のリクエストをハンドル...")
        if method == "initialize":
            response = self.handle_initialize(params, request_id)
        elif method == "tools/list":
            response = self.handle_tools_list(params, request_id)
        elif method == "tools/call":
            response = self.handle_tools_call(params, request_id)
        else:
            return self._create_error_response(
                MCPErrorCode.METHOD_NOT_FOUND, f"未知のメソッド: {method}", request_id
            )
        mcp_logger.info(f"メソッド {method} のリクエストを処理しました")
        return response

    def handle_initialize(
        self, params: Dict[str, Any], request_id: str
    ) -> Dict[str, Any]:
        """
        初期化リクエストを処理
        ベクトル検索エンジンの初期化とインデックス構築を実行
        Args:
            params (Dict[str, Any]): 初期化パラメータ
            request_id (str): リクエストID
        Returns:
            Dict[str, Any]: 初期化レスポンス
        """

        try:
            mcp_logger.info("初期化を開始...")
            self.comment_searcher.initialize_vector()
            mcp_logger.info("初期化が完了しました")
        except Exception as e:
            # エラーが発生してもサーバは動作させる
            # 埋め込みモデルの初期化時にライブラリの互換性やメモリ不足等の要因でエラーが考えられる
            mcp_logger.error(f"初期化中にエラーが発生しました: {e}")

        result = {
            "protocolVersion": MCPServerConfig.PROTOCOL_VERSION,
            "capabilities": {
                "tools": {"listChanged": False},
                "resources": {"subscribe": False, "listChanged": False},
            },
            "serverInfo": {
                "name": self.server_name,
                "version": MCPServerConfig.SERVER_VERSION,
            },
        }
        return self._create_response(result, request_id)

    def handle_tools_list(
        self, params: Dict[str, Any], request_id: str
    ) -> Dict[str, Any]:
        """
        利用可能なツール一覧を返す
        Args:
            params (Dict[str, Any]): リクエストパラメータ
            request_id (str): リクエストID
        Returns:
            Dict[str, Any]: ツール一覧レスポンス
        """

        tools = [
            {
                "name": "search_knowledge",
                "description": f"ワークスペース内のアノテーションコメントを検索します",
                "inputSchema": {
                    "type": "object",
                    "properties": {
                        "search_phrase": {
                            "type": "string",
                            "description": "検索フレーズ",
                        },
                        "use_semantic_search": {
                            "type": "boolean",
                            "description": "意味ベースの検索を行うかどうか",
                            "default": VectorSearchConfig.DEFAULT_USE_VECTOR_SEARCH,
                        },
                        "limit": {
                            "type": "integer",
                            "description": "意味ベースの検索で返す結果の最大数",
                            "default": VectorSearchConfig.DEFAULT_TOP_K,
                        },
                        "similarity_threshold": {
                            "type": "number",
                            "description": "意味ベースの検索での類似度閾値",
                            "default": VectorSearchConfig.DEFAULT_SIMILARITY_THRESHOLD,
                        },
                    },
                    "required": ["search_phrase"],
                },
            },
            {
                "name": "list_all_knowledge",
                "description": f"ワークスペース内のすべてのアノテーションコメントを一覧表示します",
                "inputSchema": {"type": "object", "properties": {}},
            },
            {
                "name": "clear_cache",
                "description": "検索結果（ベクトルデータ）のキャッシュをクリアします",
                "inputSchema": {"type": "object", "properties": {}},
            },
        ]
        return self._create_response({"tools": tools}, request_id)

    def handle_tools_call(
        self, params: Dict[str, Any], request_id: str
    ) -> Dict[str, Any]:
        """
        ツール呼び出しを処理
        Args:
            params (Dict[str, Any]): ツールパラメータ
            request_id (str): リクエストID
        Returns:
            Dict[str, Any]: ツール実行結果
        """
        tool_name = params.get("name")
        arguments = params.get("arguments", {})

        mcp_logger.info(f"ツール {tool_name} のリクエストをハンドル...")
        if tool_name == "search_knowledge":
            content = self.execute_search_knowledge(arguments)
        elif tool_name == "list_all_knowledge":
            content = self.execute_list_all_knowledge()
        elif tool_name == "clear_cache":
            content = self.execute_clear_cache()
        else:
            return self._create_error_response(
                MCPErrorCode.INTERNAL_ERROR,
                f"ツール実行エラー: 未知のツール {tool_name}",
                request_id,
            )
        mcp_logger.info(f"ツール {tool_name} のリクエストを処理しました")

        result = {"content": [{"type": "text", "text": content}]}
        return self._create_response(result, request_id)

    def execute_search_knowledge(self, arguments: Dict[str, Any]) -> str:
        """
        search_knowledge ツールを実行
        Args:
            arguments (Dict[str, Any]): ツールの引数
        Returns:
            str: 実行結果のテキスト
        """

        search_phrase = arguments.get("search_phrase", "")
        use_semantic_search = arguments.get(
            "use_semantic_search", VectorSearchConfig.DEFAULT_USE_VECTOR_SEARCH
        )
        limit = arguments.get("limit", VectorSearchConfig.DEFAULT_TOP_K)
        similarity_threshold = arguments.get(
            "similarity_threshold", VectorSearchConfig.DEFAULT_SIMILARITY_THRESHOLD
        )
        search_results = self.comment_searcher.search_knowledge(
            search_phrase, use_semantic_search, limit, similarity_threshold
        )

        content = f"検索フレーズ '{search_phrase}' を検索した結果: {len(search_results)} 件\n\n"
        for knowledge, similarity in search_results:
            similarity_str = (
                f" (類似度: {similarity:.3f})" if similarity is not None else ""
            )
            content += (
                f"📁 {knowledge.file_path}:{knowledge.line_number}{similarity_str}\n"
            )
            content += f"💡 {knowledge.content}\n\n"

        return content

    def execute_list_all_knowledge(self) -> str:
        """
        list_all_knowledge ツールを実行
        Returns:
            str: 実行結果のテキスト
        """
        knowledge_list = self.comment_searcher.get_all_knowledge()

        content = f"ワークスペース内のすべてのアノテーションコメント: {len(knowledge_list)} 件\n\n"
        for knowledge in knowledge_list:
            content += f"📁 {knowledge.file_path}:{knowledge.line_number}\n"
            content += f"💡 {knowledge.content}\n\n"

        return content

    def execute_clear_cache(self) -> str:
        """
        clear_cache ツールを実行
        Returns:
            str: 実行結果のテキスト
        """
        self.comment_searcher.clear_vector_cache()
        return (
            "ベクトル検索のキャッシュをクリアしました。次回の初期化時に再構築されます。"
        )

    def _create_response(
        self, result: Any, request_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        MCP レスポンスを作成
        Args:
            result (Any): レスポンスデータ
            request_id (Optional[str]): リクエストID
        Returns:
            Dict[str, Any]: MCPレスポンス
        """

        response = {"jsonrpc": "2.0", "result": result}
        if request_id:
            response["id"] = request_id
        return response

    def _create_error_response(
        self, error_code: int, error_message: str, request_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        MCPエラーレスポンスを作成
        Args:
            error_code (int): エラーコード
            error_message (str): エラーメッセージ
            request_id (Optional[str]): リクエストID
        Returns:
            Dict[str, Any]: MCPエラーレスポンス
        """

        response = {
            "jsonrpc": "2.0",
            "error": {"code": error_code, "message": error_message},
        }
        if request_id:
            response["id"] = request_id
        return response


class MCPErrorCode(IntEnum):
    """
    MCP エラーコード定義
    JSON-RPC 2.0 仕様に基づいた標準エラーコード
    """

    # JSON-RPC 2.0 標準エラーコード
    INVALID_REQUEST = -32600  # 無効なリクエスト
    METHOD_NOT_FOUND = -32601  # メソッドが見つからない
    INVALID_PARAMS = -32602  # 無効なパラメータ
    INTERNAL_ERROR = -32603  # 内部エラー
    PARSE_ERROR = -32700  # 無効なJSON

    # MCP固有のエラーコード（-32000 から -32099 の範囲）
    TOOL_NOT_FOUND = -32000  # ツールが見つからない
    TOOL_EXECUTION_ERROR = -32001  # ツール実行エラー
